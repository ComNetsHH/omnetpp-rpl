//
// Generated file, do not edit! Created by nedtool 5.6 from Rpl.msg.
//

#ifndef __INET_RPL_M_H
#define __INET_RPL_M_H

#if defined(__clang__)
#  pragma clang diagnostic ignored "-Wreserved-id-macro"
#endif
#include <omnetpp.h>

// nedtool version check
#define MSGC_VERSION 0x0506
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of nedtool: 'make clean' should help.
#endif


namespace inet {

class RplHeader;
class RplPacket;
class Dio;
class Dao;
class Dis;
class RplPacketInfo;
class RplTargetInfo;
class RplTransitInfo;
class SourceRoutingHeader;
} // namespace inet

#include "inet/common/INETDefs_m.h" // import inet.common.INETDefs

#include "inet/common/packet/chunk/Chunk_m.h" // import inet.common.packet.chunk.Chunk

#include "inet/networklayer/common/L3Address_m.h" // import inet.networklayer.common.L3Address

#include "inet/networklayer/contract/ipv6/Ipv6Address_m.h" // import inet.networklayer.contract.ipv6.Ipv6Address

#include "inet/networklayer/icmpv6/Icmpv6Header_m.h" // import inet.networklayer.icmpv6.Icmpv6Header

// cplusplus {{
	#include "RplDefs.h"
	#include "inet/common/geometry/common/Coord.h"
	#include <deque>
	#include <stdint.h>
// }}


namespace inet {

/**
 * Enum generated from <tt>Rpl.msg:41</tt> by nedtool.
 * <pre>
 * // Objective Code Point - defines objective function of RPL instance
 * enum Ocp
 * {
 *     ETX = 0;
 *     HOP_COUNT = 1;
 *     ENERGY = 2;
 * }
 * </pre>
 */
enum Ocp {
    ETX = 0,
    HOP_COUNT = 1,
    ENERGY = 2
};

/**
 * Enum generated from <tt>Rpl.msg:47</tt> by nedtool.
 * <pre>
 * enum RplPacketCode
 * {
 *     DIS = 0;
 *     DIO = 1;
 *     DAO = 2;
 *     DAO_ACK = 3;
 *     PING = 4;
 *     PING_ACK = 5;
 *     CROSS_LAYER_CTRL = 6;
 * }
 * 
 * 
 * //
 * // RPL packets
 * //
 * </pre>
 */
enum RplPacketCode {
    DIS = 0,
    DIO = 1,
    DAO = 2,
    DAO_ACK = 3,
    PING = 4,
    PING_ACK = 5,
    CROSS_LAYER_CTRL = 6
};

/**
 * Class generated from <tt>Rpl.msg:62</tt> by nedtool.
 * <pre>
 * class RplHeader extends Icmpv6Header
 * {
 *     RplPacketCode icmpv6Code;
 *     const uint8_t icmpv6Type = 155;
 * }
 * </pre>
 */
class RplHeader : public ::inet::Icmpv6Header
{
  protected:
    inet::RplPacketCode icmpv6Code = static_cast<inet::RplPacketCode>(-1);
    const uint8_t icmpv6Type = 155;

  private:
    void copy(const RplHeader& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const RplHeader&);

  public:
    RplHeader();
    RplHeader(const RplHeader& other);
    virtual ~RplHeader();
    RplHeader& operator=(const RplHeader& other);
    virtual RplHeader *dup() const override {return new RplHeader(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual inet::RplPacketCode getIcmpv6Code() const;
    virtual void setIcmpv6Code(inet::RplPacketCode icmpv6Code);
    virtual uint8_t getIcmpv6Type() const;
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const RplHeader& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, RplHeader& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>Rpl.msg:67</tt> by nedtool.
 * <pre>
 * class RplPacket extends FieldsChunk
 * {
 *     Ipv6Address destAddress;
 *     Ipv6Address srcAddress;
 *     uint8_t instanceId;        	  	// RPL instance ID
 *     Ipv6Address dodagId;            // IPv6 address of the DODAG root
 *     uint64_t nodeId; 				// Node's MAC (temp. workaround for cross-layer 6TiSCH)
 * }
 * </pre>
 */
class RplPacket : public ::inet::FieldsChunk
{
  protected:
    Ipv6Address destAddress;
    Ipv6Address srcAddress;
    uint8_t instanceId = 0;
    Ipv6Address dodagId;
    uint64_t nodeId = 0;

  private:
    void copy(const RplPacket& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const RplPacket&);

  public:
    RplPacket();
    RplPacket(const RplPacket& other);
    virtual ~RplPacket();
    RplPacket& operator=(const RplPacket& other);
    virtual RplPacket *dup() const override {return new RplPacket(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual const Ipv6Address& getDestAddress() const;
    virtual Ipv6Address& getDestAddressForUpdate() { handleChange();return const_cast<Ipv6Address&>(const_cast<RplPacket*>(this)->getDestAddress());}
    virtual void setDestAddress(const Ipv6Address& destAddress);
    virtual const Ipv6Address& getSrcAddress() const;
    virtual Ipv6Address& getSrcAddressForUpdate() { handleChange();return const_cast<Ipv6Address&>(const_cast<RplPacket*>(this)->getSrcAddress());}
    virtual void setSrcAddress(const Ipv6Address& srcAddress);
    virtual uint8_t getInstanceId() const;
    virtual void setInstanceId(uint8_t instanceId);
    virtual const Ipv6Address& getDodagId() const;
    virtual Ipv6Address& getDodagIdForUpdate() { handleChange();return const_cast<Ipv6Address&>(const_cast<RplPacket*>(this)->getDodagId());}
    virtual void setDodagId(const Ipv6Address& dodagId);
    virtual uint64_t getNodeId() const;
    virtual void setNodeId(uint64_t nodeId);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const RplPacket& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, RplPacket& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>Rpl.msg:76</tt> by nedtool.
 * <pre>
 * // DODAG Information Option [RFC 6550, 6.3]
 * class Dio extends RplPacket
 * {
 *     // DODAG version number, may be incremented by the root to trigger topology refresh 
 *     uint8_t dodagVersion;
 *     uint16_t rank;            	 	// Node's rank within the DODAG 
 *     bool storing;					// Mode of operation: storing / non-storing                
 *     bool grounded;              	// DODAG grounded flag, indicates whether sink is connected to backbone	   
 * 
 *     // Destination Advertisement Trigger Sequence Number, 
 *     // may be incremented to trigger downward routes update
 *     uint8_t dtsn;
 *     uint8_t dioId;  // temporary field for debugging purposes   
 * 
 * 	// Trickle timer parameters (DAG Configuration Option)
 *     int minInterval;
 *     int dioRedundancyConst;
 *     int dioNumDoublings;
 *     Ocp ocp;
 * 
 *     // Non-RFC fields, misc
 *     Coord position; // DIO sender node location to draw directed parent-child connectors on canvas
 *     cFigure::Color color; // Color of the parent-child connector line, per DODAG
 *     int colorId; // DODAG color id (from static palette) for multi-GW scenario
 * 
 * }
 * </pre>
 */
class Dio : public ::inet::RplPacket
{
  protected:
    uint8_t dodagVersion = 0;
    uint16_t rank = 0;
    bool storing = false;
    bool grounded = false;
    uint8_t dtsn = 0;
    uint8_t dioId = 0;
    int minInterval = 0;
    int dioRedundancyConst = 0;
    int dioNumDoublings = 0;
    inet::Ocp ocp = static_cast<inet::Ocp>(-1);
    Coord position;
    cFigure::Color color;
    int colorId = 0;

  private:
    void copy(const Dio& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Dio&);

  public:
    Dio();
    Dio(const Dio& other);
    virtual ~Dio();
    Dio& operator=(const Dio& other);
    virtual Dio *dup() const override {return new Dio(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint8_t getDodagVersion() const;
    virtual void setDodagVersion(uint8_t dodagVersion);
    virtual uint16_t getRank() const;
    virtual void setRank(uint16_t rank);
    virtual bool getStoring() const;
    virtual void setStoring(bool storing);
    virtual bool getGrounded() const;
    virtual void setGrounded(bool grounded);
    virtual uint8_t getDtsn() const;
    virtual void setDtsn(uint8_t dtsn);
    virtual uint8_t getDioId() const;
    virtual void setDioId(uint8_t dioId);
    virtual int getMinInterval() const;
    virtual void setMinInterval(int minInterval);
    virtual int getDioRedundancyConst() const;
    virtual void setDioRedundancyConst(int dioRedundancyConst);
    virtual int getDioNumDoublings() const;
    virtual void setDioNumDoublings(int dioNumDoublings);
    virtual inet::Ocp getOcp() const;
    virtual void setOcp(inet::Ocp ocp);
    virtual const Coord& getPosition() const;
    virtual Coord& getPositionForUpdate() { handleChange();return const_cast<Coord&>(const_cast<Dio*>(this)->getPosition());}
    virtual void setPosition(const Coord& position);
    virtual const cFigure::Color& getColor() const;
    virtual cFigure::Color& getColorForUpdate() { handleChange();return const_cast<cFigure::Color&>(const_cast<Dio*>(this)->getColor());}
    virtual void setColor(const cFigure::Color& color);
    virtual int getColorId() const;
    virtual void setColorId(int colorId);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Dio& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Dio& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>Rpl.msg:102</tt> by nedtool.
 * <pre>
 * // Destination Advertisement Object [RFC 6550, 6.4] 
 * class Dao extends RplPacket
 * {
 *     uint8_t seqNum;				// ID for each unique DAO sent by a node
 *     bool daoAckRequired;		// indicates whether DAO-ACK is expected by the sender 
 *     Ipv6Address reachableDest;	// advertised reachable destination		
 *     uint8_t chOffset;			// advertised channel offset (unique per branch)
 *     						    // as part of cross-layer scheduling 
 * }
 * </pre>
 */
class Dao : public ::inet::RplPacket
{
  protected:
    uint8_t seqNum = 0;
    bool daoAckRequired = false;
    Ipv6Address reachableDest;
    uint8_t chOffset = 0;

  private:
    void copy(const Dao& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Dao&);

  public:
    Dao();
    Dao(const Dao& other);
    virtual ~Dao();
    Dao& operator=(const Dao& other);
    virtual Dao *dup() const override {return new Dao(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint8_t getSeqNum() const;
    virtual void setSeqNum(uint8_t seqNum);
    virtual bool getDaoAckRequired() const;
    virtual void setDaoAckRequired(bool daoAckRequired);
    virtual const Ipv6Address& getReachableDest() const;
    virtual Ipv6Address& getReachableDestForUpdate() { handleChange();return const_cast<Ipv6Address&>(const_cast<Dao*>(this)->getReachableDest());}
    virtual void setReachableDest(const Ipv6Address& reachableDest);
    virtual uint8_t getChOffset() const;
    virtual void setChOffset(uint8_t chOffset);

	std::vector<Ipv6Address> knownTargets; 
	
	std::vector<Ipv6Address> getKnownTargets() { return this->knownTargets; }
	void setKnownTargets(std::vector<Ipv6Address> knownTargets) { handleChange(); this->knownTargets = knownTargets; }
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Dao& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Dao& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>Rpl.msg:118</tt> by nedtool.
 * <pre>
 * // DODAG Information Solicitation
 * class Dis extends RplPacket
 * {
 * }
 * </pre>
 */
class Dis : public ::inet::RplPacket
{
  protected:

  private:
    void copy(const Dis& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Dis&);

  public:
    Dis();
    Dis(const Dis& other);
    virtual ~Dis();
    Dis& operator=(const Dis& other);
    virtual Dis *dup() const override {return new Dis(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Dis& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Dis& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>Rpl.msg:123</tt> by nedtool.
 * <pre>
 * // RPL Information Packet header [RFC 6550 11.2]
 * class RplPacketInfo extends RplPacket
 * {
 *     bool down;
 *     bool rankError;
 *     bool fwdError;
 *     uint16_t senderRank;
 * }
 * </pre>
 */
class RplPacketInfo : public ::inet::RplPacket
{
  protected:
    bool down = false;
    bool rankError = false;
    bool fwdError = false;
    uint16_t senderRank = 0;

  private:
    void copy(const RplPacketInfo& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const RplPacketInfo&);

  public:
    RplPacketInfo();
    RplPacketInfo(const RplPacketInfo& other);
    virtual ~RplPacketInfo();
    RplPacketInfo& operator=(const RplPacketInfo& other);
    virtual RplPacketInfo *dup() const override {return new RplPacketInfo(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual bool getDown() const;
    virtual void setDown(bool down);
    virtual bool getRankError() const;
    virtual void setRankError(bool rankError);
    virtual bool getFwdError() const;
    virtual void setFwdError(bool fwdError);
    virtual uint16_t getSenderRank() const;
    virtual void setSenderRank(uint16_t senderRank);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const RplPacketInfo& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, RplPacketInfo& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>Rpl.msg:131</tt> by nedtool.
 * <pre>
 * class RplTargetInfo extends RplPacket
 * {
 *     Ipv6Address target;
 *     // tbd fields according to 
 * }
 * </pre>
 */
class RplTargetInfo : public ::inet::RplPacket
{
  protected:
    Ipv6Address target;

  private:
    void copy(const RplTargetInfo& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const RplTargetInfo&);

  public:
    RplTargetInfo();
    RplTargetInfo(const RplTargetInfo& other);
    virtual ~RplTargetInfo();
    RplTargetInfo& operator=(const RplTargetInfo& other);
    virtual RplTargetInfo *dup() const override {return new RplTargetInfo(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual const Ipv6Address& getTarget() const;
    virtual Ipv6Address& getTargetForUpdate() { handleChange();return const_cast<Ipv6Address&>(const_cast<RplTargetInfo*>(this)->getTarget());}
    virtual void setTarget(const Ipv6Address& target);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const RplTargetInfo& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, RplTargetInfo& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>Rpl.msg:136</tt> by nedtool.
 * <pre>
 * class RplTransitInfo extends RplPacket
 * {
 *     Ipv6Address transit;
 *     // tbd fields
 * }
 * </pre>
 */
class RplTransitInfo : public ::inet::RplPacket
{
  protected:
    Ipv6Address transit;

  private:
    void copy(const RplTransitInfo& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const RplTransitInfo&);

  public:
    RplTransitInfo();
    RplTransitInfo(const RplTransitInfo& other);
    virtual ~RplTransitInfo();
    RplTransitInfo& operator=(const RplTransitInfo& other);
    virtual RplTransitInfo *dup() const override {return new RplTransitInfo(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual const Ipv6Address& getTransit() const;
    virtual Ipv6Address& getTransitForUpdate() { handleChange();return const_cast<Ipv6Address&>(const_cast<RplTransitInfo*>(this)->getTransit());}
    virtual void setTransit(const Ipv6Address& transit);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const RplTransitInfo& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, RplTransitInfo& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>Rpl.msg:143</tt> by nedtool.
 * <pre>
 * class SourceRoutingHeader extends FieldsChunk
 * {
 * }
 * </pre>
 */
class SourceRoutingHeader : public ::inet::FieldsChunk
{
  protected:

  private:
    void copy(const SourceRoutingHeader& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SourceRoutingHeader&);

  public:
    SourceRoutingHeader();
    SourceRoutingHeader(const SourceRoutingHeader& other);
    virtual ~SourceRoutingHeader();
    SourceRoutingHeader& operator=(const SourceRoutingHeader& other);
    virtual SourceRoutingHeader *dup() const override {return new SourceRoutingHeader(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods

    std::deque<Ipv6Address> addresses;
    
    std::deque<Ipv6Address> getAddresses() { return this->addresses; }
    void setAddresses(std::deque<Ipv6Address> hopList) { handleChange(); this->addresses = hopList; }	
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SourceRoutingHeader& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SourceRoutingHeader& obj) {obj.parsimUnpack(b);}

} // namespace inet

#endif // ifndef __INET_RPL_M_H

